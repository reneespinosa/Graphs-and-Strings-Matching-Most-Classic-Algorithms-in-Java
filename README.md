# Classic Graphs and Strings Algorithms in Java

This repository contains implementations of classic algorithms for graphs and string matching in Java. The algorithms cover a wide range of applications, from graph processing to efficient string matching.

## Contents

- **Graph Algorithms**:
  - **Depth-First Search (DFS)**: An algorithm for traversing or searching in a graph or tree.
  - **Breadth-First Search (BFS)**: An algorithm for traversing or searching in a graph or tree iteratively.
  - **BFS Shortest Path**: An algorithm to find the shortest paths between nodes in unweighted graphs using BFS.
  - **Dijkstra's Algorithm**:  An algorithm to find the shortest paths between nodes in weighted graphs with positive weights. It includes both general versions and optimized versions for dense graphs.
  - **Bellman-Ford Algorithm**: An algorithm to find the shortest paths between nodes in graphs with negative weights.
  - **Floyd-Warshall Algorithm**: An algorithm to find the shortest paths in a weighted graph with positive or negative edge weights (but with no negative cycles).
  - **Topological Sorting**: An algorithm to sort the nodes of a directed acyclic graph.
  - **Shortest Paths in DAGs (Directed Acyclic Graphs)**: Algorithm to find the shortest paths in directed acyclic graphs.

- **String Matching Algorithms**:
  - **Knuth-Morris-Pratt (KMP)**: A linear-time algorithm for substring searching in text.
  - **Hashing**: An approach to string matching that involves converting strings into numerical representations using hash functions, enabling fast pattern matching.
  - **Trie (Prefix Tree)**: A tree-like data structure used to store a dynamic set of strings, making it efficient for searching and retrieving strings with a common prefix.
  

## Other Implementations and Competitive Programming

Some implementations in this repository are geared towards educational purposes or real-world applications, while others are tailored for competitive programming. Additionally, code from users of [CSES](https://cses.fi/) (Code Submission Evaluation System) has been included.

## Origin of Code

A significant portion of the code in this repository is adapted from the repository [Saborit10/conferencias_2cc](https://github.com/Saborit10/conferencias_2cc).

## Key Features

- **Flexibility**: Algorithms are designed to adapt to different data types and requirements.
- **Efficiency**: Efficient programming techniques are used to optimize performance.
- **Ease of Use**: Implementations are designed to be easy to understand and use.

## Getting Started

To use the algorithms in this repository:

1. **Clone the Repository**: Use `git clone` to clone this repository to your local machine.
2. **Explore the Algorithms**: Navigate through the directories to find the algorithms you need.
3. **Run Examples**: Refer to the provided examples in the code to understand how to use the algorithms.

## Contributions

To contribute to this project please check out the [contribution guidelines](https://github.com/YurisCodingClub/accessibility-mentor/blob/main/CONTRIBUTING.md).

## License

This project is released under The Unlicense, which means it is in the public domain and has no copyright. See the `LICENSE` file for more details.

## Contact

If you have any questions, feel free to reach out to me at [reneespinosa.dev@gmail.com](mailto:reneespinosa.dev@gmail.com).
